{"version":3,"file":"iblShadowsVoxelRenderer.js","sourceRoot":"","sources":["../../../../../dev/core/src/Rendering/IBLShadows/iblShadowsVoxelRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constants } from \"../../Engines/constants\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { WebGPUEngine } from \"../../Engines/webgpuEngine\";\r\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\r\nimport { MultiRenderTarget } from \"../../Materials/Textures/multiRenderTarget\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { RenderTargetTextureOptions } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport \"../../Shaders/voxelGrid.fragment\";\r\nimport \"../../Shaders/voxelGrid.vertex\";\r\nimport \"../../Shaders/voxelGrid2dArrayDebug.fragment\";\r\nimport \"../../Shaders/voxelGrid3dDebug.fragment\";\r\nimport \"../../Shaders/voxelSlabDebug.vertex\";\r\nimport \"../../Shaders/voxelSlabDebug.fragment\";\r\nimport \"../../Shaders/combineVoxelGrids.fragment\";\r\nimport \"../../Shaders/generateVoxelMip.fragment\";\r\nimport \"../../Shaders/copyTexture3DLayerToTexture.fragment\";\r\n\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport { EffectRenderer, EffectWrapper } from \"../../Materials/effectRenderer\";\r\nimport type { IblShadowsRenderPipeline } from \"./iblShadowsRenderPipeline\";\r\nimport type { RenderTargetWrapper } from \"core/Engines\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Voxel-based shadow rendering for IBL's.\r\n * This should not be instanciated directly, as it is part of a scene component\r\n * @internal\r\n */\r\nexport class _IblShadowsVoxelRenderer {\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _renderPipeline: IblShadowsRenderPipeline;\r\n    private _voxelGridRT: ProceduralTexture;\r\n    private _voxelGridXaxis: RenderTargetTexture;\r\n    private _voxelGridYaxis: RenderTargetTexture;\r\n    private _voxelGridZaxis: RenderTargetTexture;\r\n    private _voxelMrtsXaxis: MultiRenderTarget[] = [];\r\n    private _voxelMrtsYaxis: MultiRenderTarget[] = [];\r\n    private _voxelMrtsZaxis: MultiRenderTarget[] = [];\r\n    private _isVoxelGrid3D: boolean = true;\r\n\r\n    /**\r\n     * Return the voxel grid texture.\r\n     * @returns The voxel grid texture.\r\n     */\r\n    public getVoxelGrid(): ProceduralTexture | RenderTargetTexture {\r\n        if (this._triPlanarVoxelization) {\r\n            return this._voxelGridRT;\r\n        } else {\r\n            return this._voxelGridZaxis;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The debug pass post process\r\n     * @returns The debug pass post process\r\n     */\r\n    public getDebugPassPP(): PostProcess {\r\n        if (!this._voxelDebugPass) {\r\n            this._createDebugPass();\r\n        }\r\n        return this._voxelDebugPass;\r\n    }\r\n\r\n    private _maxDrawBuffers: number;\r\n    private _renderTargets: RenderTargetTexture[] = [];\r\n\r\n    private _triPlanarVoxelization: boolean = true;\r\n\r\n    /**\r\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\r\n     */\r\n    public get triPlanarVoxelization(): boolean {\r\n        return this._triPlanarVoxelization;\r\n    }\r\n\r\n    /**\r\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\r\n     */\r\n    public set triPlanarVoxelization(enabled: boolean) {\r\n        if (this._triPlanarVoxelization === enabled) {\r\n            return;\r\n        }\r\n        this._triPlanarVoxelization = enabled;\r\n        this._disposeVoxelTextures();\r\n        this._createTextures();\r\n        this._renderPipeline.updateVoxelization();\r\n    }\r\n\r\n    private _voxelizationInProgress: boolean = false;\r\n    private _invWorldScaleMatrix: Matrix;\r\n\r\n    /**\r\n     * Set the matrix to use for scaling the world space to voxel space\r\n     * @param matrix The matrix to use for scaling the world space to voxel space\r\n     */\r\n    public setWorldScaleMatrix(matrix: Matrix) {\r\n        this._invWorldScaleMatrix = matrix;\r\n    }\r\n    /**\r\n     * @returns Whether voxelization is currently happening.\r\n     */\r\n    public isVoxelizationInProgress(): boolean {\r\n        return this._voxelizationInProgress;\r\n    }\r\n\r\n    private _voxelResolution: number = 64;\r\n    private _voxelResolutionExp: number = 6;\r\n\r\n    /**\r\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\r\n     */\r\n    public get voxelResolutionExp(): number {\r\n        return this._voxelResolutionExp;\r\n    }\r\n\r\n    /**\r\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\r\n     */\r\n    public set voxelResolutionExp(resolutionExp: number) {\r\n        if (this._voxelResolutionExp === resolutionExp && this._voxelGridZaxis) {\r\n            return;\r\n        }\r\n        this._voxelResolutionExp = Math.round(Math.min(Math.max(resolutionExp, 3), 9));\r\n        this._voxelResolution = Math.pow(2.0, this._voxelResolutionExp);\r\n        this._disposeVoxelTextures();\r\n        this._createTextures();\r\n    }\r\n\r\n    /**\r\n     * Observable that will be triggered when the voxel grid is ready to be used\r\n     */\r\n    public onReadyObservable: Observable<void> = new Observable<void>();\r\n\r\n    private _copyMipEffectRenderer: EffectRenderer;\r\n    private _copyMipEffectWrapper: EffectWrapper;\r\n    private _mipArray: ProceduralTexture[] = [];\r\n\r\n    private _voxelSlabDebugRT: RenderTargetTexture;\r\n    private _voxelDebugPass: PostProcess;\r\n    private _voxelDebugEnabled: boolean = false;\r\n\r\n    /**\r\n     * Shows only the voxels that were rendered along a particular axis (while using triPlanarVoxelization).\r\n     * If not set, the combined voxel grid will be shown.\r\n     * Note: This only works when the debugMipNumber is set to 0 because we don't generate mips for each axis.\r\n     * @param axis The axis to show (0 = x, 1 = y, 2 = z)\r\n     */\r\n    public set voxelDebugAxis(axis: number) {\r\n        this._voxelDebugAxis = axis;\r\n    }\r\n\r\n    public get voxelDebugAxis(): number {\r\n        return this._voxelDebugAxis;\r\n    }\r\n    private _voxelDebugAxis: number = -1;\r\n    private _debugSizeParams: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * Sets params that control the position and scaling of the debug display on the screen.\r\n     * @param x Screen X offset of the debug display (0-1)\r\n     * @param y Screen Y offset of the debug display (0-1)\r\n     * @param widthScale X scale of the debug display (0-1)\r\n     * @param heightScale Y scale of the debug display (0-1)\r\n     */\r\n    public setDebugDisplayParams(x: number, y: number, widthScale: number, heightScale: number) {\r\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\r\n    }\r\n    private _debugMipNumber: number = 0;\r\n    /**\r\n     * The mip level to show in the debug display\r\n     * @param mipNum The mip level to show in the debug display\r\n     */\r\n    public setDebugMipNumber(mipNum: number) {\r\n        this._debugMipNumber = mipNum;\r\n    }\r\n    private _debugPassName: string = \"Voxelization Debug Pass\";\r\n    /**\r\n     * Sets the name of the debug pass\r\n     */\r\n    public get debugPassName(): string {\r\n        return this._debugPassName;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the debug view for this pass\r\n     */\r\n    public get voxelDebugEnabled(): boolean {\r\n        return this._voxelDebugEnabled;\r\n    }\r\n\r\n    public set voxelDebugEnabled(enabled: boolean) {\r\n        if (this._voxelDebugEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._voxelDebugEnabled = enabled;\r\n        if (enabled) {\r\n            this._voxelSlabDebugRT = new RenderTargetTexture(\"voxelSlabDebug\", { ratio: 1 }, this._scene, {\r\n                generateDepthBuffer: true,\r\n                generateMipMaps: false,\r\n                type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n                format: Constants.TEXTUREFORMAT_R,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            });\r\n            this._voxelSlabDebugRT.noPrePassRenderer = true;\r\n        } else {\r\n            if (this._voxelSlabDebugRT) {\r\n                this._removeVoxelRTs([this._voxelSlabDebugRT]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the debug post process effect for this pass\r\n     */\r\n    private _createDebugPass() {\r\n        if (!this._voxelDebugPass) {\r\n            const debugOptions: PostProcessOptions = {\r\n                width: this._engine.getRenderWidth(),\r\n                height: this._engine.getRenderHeight(),\r\n                textureFormat: Constants.TEXTUREFORMAT_R,\r\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                uniforms: [\"sizeParams\", \"mipNumber\"],\r\n                samplers: [\"voxelTexture\", \"voxelSlabTexture\"],\r\n                engine: this._engine,\r\n                reusable: false,\r\n            };\r\n            this._voxelDebugPass = new PostProcess(this.debugPassName, this._isVoxelGrid3D ? \"voxelGrid3dDebug\" : \"voxelGrid2dArrayDebug\", debugOptions);\r\n            this._voxelDebugPass.onApplyObservable.add((effect) => {\r\n                if (this._voxelDebugAxis === 0) {\r\n                    effect.setTexture(\"voxelTexture\", this._voxelGridXaxis);\r\n                } else if (this._voxelDebugAxis === 1) {\r\n                    effect.setTexture(\"voxelTexture\", this._voxelGridYaxis);\r\n                } else if (this._voxelDebugAxis === 2) {\r\n                    effect.setTexture(\"voxelTexture\", this._voxelGridZaxis);\r\n                } else {\r\n                    effect.setTexture(\"voxelTexture\", this.getVoxelGrid());\r\n                }\r\n                effect.setTexture(\"voxelSlabTexture\", this._voxelSlabDebugRT);\r\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\r\n                effect.setFloat(\"mipNumber\", this._debugMipNumber);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instanciates the voxel renderer\r\n     * @param scene Scene to attach to\r\n     * @param iblShadowsRenderPipeline The render pipeline this pass is associated with\r\n     * @param resolutionExp Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\r\n     * @param triPlanarVoxelization Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\r\n     * @returns The voxel renderer\r\n     */\r\n    constructor(scene: Scene, iblShadowsRenderPipeline: IblShadowsRenderPipeline, resolutionExp: number = 6, triPlanarVoxelization: boolean = true) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine() as Engine;\r\n        this._triPlanarVoxelization = triPlanarVoxelization;\r\n        this._renderPipeline = iblShadowsRenderPipeline;\r\n        if (!this._engine.getCaps().drawBuffersExtension) {\r\n            Logger.Error(\"Can't do voxel rendering without the draw buffers extension.\");\r\n        }\r\n\r\n        if (this._engine instanceof WebGPUEngine) {\r\n            this._maxDrawBuffers = 8; // TODO - get this from the WebGPU engine?\r\n        } else {\r\n            this._maxDrawBuffers = (this._engine as Engine)._gl.getParameter((this._engine as Engine)._gl.MAX_DRAW_BUFFERS);\r\n        }\r\n\r\n        this._copyMipEffectRenderer = new EffectRenderer(this._engine);\r\n        this._copyMipEffectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            fragmentShader: \"copyTexture3DLayerToTexture\",\r\n            useShaderStore: true,\r\n            uniformNames: [\"layerNum\"],\r\n            samplerNames: [\"textureSampler\"],\r\n        });\r\n\r\n        this.voxelResolutionExp = resolutionExp;\r\n    }\r\n\r\n    private _generateMipMaps() {\r\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\r\n        for (let i = 1; i < iterations + 1; i++) {\r\n            this._generateMipMap(i);\r\n        }\r\n    }\r\n\r\n    private _generateMipMap(lodLevel: number) {\r\n        // Generate a mip map for the given level by triggering the render of the procedural mip texture.\r\n        const mipTarget = this._mipArray[lodLevel - 1];\r\n        if (!mipTarget) {\r\n            return;\r\n        }\r\n        mipTarget.setTexture(\"srcMip\", lodLevel === 1 ? this.getVoxelGrid() : this._mipArray[lodLevel - 2]);\r\n        mipTarget.render();\r\n    }\r\n\r\n    private _copyMipMaps() {\r\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\r\n        for (let i = 1; i < iterations + 1; i++) {\r\n            this._copyMipMap(i);\r\n        }\r\n    }\r\n\r\n    private _copyMipMap(lodLevel: number) {\r\n        // Now, copy this mip into the mip chain of the voxel grid.\r\n        // TODO - this currently isn't working. \"textureSampler\" isn't being properly set to mipTarget.\r\n        const mipTarget = this._mipArray[lodLevel - 1];\r\n        if (!mipTarget) {\r\n            return;\r\n        }\r\n        const voxelGrid = this.getVoxelGrid();\r\n        let rt: RenderTargetWrapper;\r\n        if (voxelGrid instanceof RenderTargetTexture && voxelGrid.renderTarget) {\r\n            rt = voxelGrid.renderTarget;\r\n        } else {\r\n            rt = (voxelGrid as any)._rtWrapper;\r\n        }\r\n        if (rt) {\r\n            this._copyMipEffectRenderer.saveStates();\r\n            const bindSize = mipTarget.getSize().width;\r\n\r\n            // Render to each layer of the voxel grid.\r\n            for (let layer = 0; layer < bindSize; layer++) {\r\n                this._engine.bindFramebuffer(rt, 0, bindSize, bindSize, true, lodLevel, layer);\r\n                this._copyMipEffectRenderer.applyEffectWrapper(this._copyMipEffectWrapper);\r\n                this._copyMipEffectWrapper.effect.setTexture(\"textureSampler\", mipTarget);\r\n                this._copyMipEffectWrapper.effect.setInt(\"layerNum\", layer);\r\n                this._copyMipEffectRenderer.draw();\r\n                this._engine.unBindFramebuffer(rt, true);\r\n            }\r\n            this._copyMipEffectRenderer.restoreStates();\r\n        }\r\n    }\r\n\r\n    private _computeNumberOfSlabs(): number {\r\n        return Math.ceil(this._voxelResolution / this._maxDrawBuffers);\r\n    }\r\n\r\n    private _createTextures() {\r\n        const size: TextureSize = {\r\n            width: this._voxelResolution,\r\n            height: this._voxelResolution,\r\n            layers: this._isVoxelGrid3D ? undefined : this._voxelResolution,\r\n            depth: this._isVoxelGrid3D ? this._voxelResolution : undefined,\r\n        };\r\n        const voxelAxisOptions: RenderTargetTextureOptions = {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: false,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            format: Constants.TEXTUREFORMAT_R,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        };\r\n\r\n        // We can render up to maxDrawBuffers voxel slices of the grid per render.\r\n        // We call this a slab.\r\n        const numSlabs = this._computeNumberOfSlabs();\r\n        const voxelCombinedOptions: RenderTargetTextureOptions = {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            format: Constants.TEXTUREFORMAT_R,\r\n            samplingMode: Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST,\r\n        };\r\n        if (this._triPlanarVoxelization) {\r\n            this._voxelGridXaxis = new RenderTargetTexture(\"voxelGridXaxis\", size, this._scene, voxelAxisOptions);\r\n            this._voxelGridYaxis = new RenderTargetTexture(\"voxelGridYaxis\", size, this._scene, voxelAxisOptions);\r\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelAxisOptions);\r\n            this._voxelMrtsXaxis = this._createVoxelMRTs(\"x_axis_\", this._voxelGridXaxis, numSlabs);\r\n            this._voxelMrtsYaxis = this._createVoxelMRTs(\"y_axis_\", this._voxelGridYaxis, numSlabs);\r\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\r\n\r\n            this._voxelGridRT = new ProceduralTexture(\"combinedVoxelGrid\", size, \"combineVoxelGrids\", this._scene, voxelCombinedOptions, true);\r\n            this._voxelGridRT.isRenderTarget = true;\r\n            this._voxelGridRT.setFloat(\"layer\", 0.0);\r\n            this._voxelGridRT.setTexture(\"voxelXaxisSampler\", this._voxelGridXaxis);\r\n            this._voxelGridRT.setTexture(\"voxelYaxisSampler\", this._voxelGridYaxis);\r\n            this._voxelGridRT.setTexture(\"voxelZaxisSampler\", this._voxelGridZaxis);\r\n            // We will render this only after voxelization is completed for the 3 axes.\r\n            this._voxelGridRT.autoClear = false;\r\n            this._voxelGridRT.refreshRate = 0;\r\n            this._voxelGridRT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this._voxelGridRT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        } else {\r\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelCombinedOptions);\r\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\r\n        }\r\n\r\n        this._mipArray = new Array(Math.ceil(Math.log2(this._voxelResolution)));\r\n        for (let mipIdx = 1; mipIdx <= this._mipArray.length; mipIdx++) {\r\n            const mipDim = this._voxelResolution >> mipIdx;\r\n            const mipSize: TextureSize = { width: mipDim, height: mipDim, depth: mipDim };\r\n            this._mipArray[mipIdx - 1] = new ProceduralTexture(\"voxelMip\" + mipIdx, mipSize, \"generateVoxelMip\", this._scene, voxelAxisOptions);\r\n\r\n            const mipTarget = this._mipArray[mipIdx - 1];\r\n            mipTarget._noMipmap = true;\r\n            mipTarget.refreshRate = 0;\r\n            mipTarget.autoClear = false;\r\n            mipTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            mipTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            mipTarget.setTexture(\"srcMip\", mipIdx > 1 ? this._mipArray[mipIdx - 2] : this.getVoxelGrid());\r\n            mipTarget.setInt(\"layerNum\", 0);\r\n        }\r\n    }\r\n\r\n    private _createVoxelMRTs(name: string, voxelRT: RenderTargetTexture, numSlabs: number): MultiRenderTarget[] {\r\n        voxelRT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        voxelRT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        voxelRT.noPrePassRenderer = true;\r\n        const mrtArray: MultiRenderTarget[] = [];\r\n        const targetTypes = new Array(this._maxDrawBuffers).fill(this._isVoxelGrid3D ? Constants.TEXTURE_3D : Constants.TEXTURE_2D_ARRAY);\r\n\r\n        for (let mrt_index = 0; mrt_index < numSlabs; mrt_index++) {\r\n            let layerIndices = new Array(this._maxDrawBuffers).fill(0);\r\n            layerIndices = layerIndices.map((value, index) => mrt_index * this._maxDrawBuffers + index);\r\n\r\n            let textureNames = new Array(this._maxDrawBuffers).fill(\"\");\r\n            textureNames = textureNames.map((value, index) => \"voxel_grid_\" + name + (mrt_index * this._maxDrawBuffers + index));\r\n\r\n            const mrt = new MultiRenderTarget(\r\n                \"mrt_\" + name + mrt_index,\r\n                { width: this._voxelResolution, height: this._voxelResolution, depth: this._isVoxelGrid3D ? this._voxelResolution : undefined },\r\n                this._maxDrawBuffers, // number of draw buffers\r\n                this._scene,\r\n                {\r\n                    types: new Array(this._maxDrawBuffers).fill(Constants.TEXTURETYPE_UNSIGNED_BYTE),\r\n                    samplingModes: new Array(this._maxDrawBuffers).fill(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE),\r\n                    generateMipMaps: false,\r\n                    targetTypes,\r\n                    formats: new Array(this._maxDrawBuffers).fill(Constants.TEXTUREFORMAT_R),\r\n                    faceIndex: new Array(this._maxDrawBuffers).fill(0),\r\n                    layerIndex: layerIndices,\r\n                    layerCounts: new Array(this._maxDrawBuffers).fill(this._voxelResolution),\r\n                    generateDepthBuffer: false,\r\n                    generateStencilBuffer: false,\r\n                },\r\n                textureNames\r\n            );\r\n\r\n            mrt.clearColor = new Color4(0, 0, 0, 1);\r\n            mrt.noPrePassRenderer = true;\r\n            for (let i = 0; i < this._maxDrawBuffers; i++) {\r\n                mrt.setInternalTexture(voxelRT.getInternalTexture()!, i);\r\n            }\r\n\r\n            mrtArray.push(mrt);\r\n        }\r\n        return mrtArray;\r\n    }\r\n\r\n    private _disposeVoxelTextures() {\r\n        this._stopVoxelization();\r\n        for (let i = 0; i < this._voxelMrtsZaxis.length; i++) {\r\n            if (this._triPlanarVoxelization) {\r\n                this._voxelMrtsXaxis[i].dispose(true);\r\n                this._voxelMrtsYaxis[i].dispose(true);\r\n            }\r\n            this._voxelMrtsZaxis[i].dispose(true);\r\n        }\r\n        if (this._triPlanarVoxelization) {\r\n            this._voxelGridXaxis?.dispose();\r\n            this._voxelGridYaxis?.dispose();\r\n            this._voxelGridRT?.dispose();\r\n        }\r\n        this._voxelGridZaxis?.dispose();\r\n        this._mipArray.forEach((mip) => {\r\n            mip.dispose();\r\n        });\r\n        this._mipArray = [];\r\n        this._voxelMrtsXaxis = [];\r\n        this._voxelMrtsYaxis = [];\r\n        this._voxelMrtsZaxis = [];\r\n    }\r\n\r\n    private _createVoxelMaterial(): ShaderMaterial {\r\n        const voxelMaterial = new ShaderMaterial(\"voxelization\", this._scene, \"voxelGrid\", {\r\n            uniforms: [\"world\", \"viewMatrix\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\r\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\r\n        });\r\n        voxelMaterial.cullBackFaces = false;\r\n        voxelMaterial.backFaceCulling = false;\r\n        voxelMaterial.depthFunction = Engine.ALWAYS;\r\n        return voxelMaterial;\r\n    }\r\n\r\n    /**\r\n     * Checks if the voxel renderer is ready to voxelize scene\r\n     * @returns true if the voxel renderer is ready to voxelize scene\r\n     */\r\n    public isReady() {\r\n        if (!this.getVoxelGrid().isReady() || this._voxelizationInProgress) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * If the MRT's are already in the list of render targets, this will\r\n     * remove them so that they don't get rendered again.\r\n     */\r\n    private _stopVoxelization() {\r\n        // If the MRT's are already in the list of render targets, remove them.\r\n        this._removeVoxelRTs(this._voxelMrtsXaxis);\r\n        this._removeVoxelRTs(this._voxelMrtsYaxis);\r\n        this._removeVoxelRTs(this._voxelMrtsZaxis);\r\n    }\r\n\r\n    private _removeVoxelRTs(rts: RenderTargetTexture[]) {\r\n        // const currentRTs = this._scene.customRenderTargets;\r\n        const rtIdx = this._renderTargets.findIndex((rt) => {\r\n            if (rt === rts[0]) return true;\r\n            return false;\r\n        });\r\n        if (rtIdx >= 0) {\r\n            this._renderTargets.splice(rtIdx, rts.length);\r\n        } else {\r\n            const rtIdx = this._scene.customRenderTargets.findIndex((rt) => {\r\n                if (rt === rts[0]) return true;\r\n                return false;\r\n            });\r\n            if (rtIdx >= 0) {\r\n                this._scene.customRenderTargets.splice(rtIdx, rts.length);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders voxel grid of scene for IBL shadows\r\n     * @param excludedMeshes\r\n     */\r\n    public updateVoxelGrid(excludedMeshes: number[]) {\r\n        this._stopVoxelization();\r\n\r\n        this._voxelizationInProgress = true;\r\n\r\n        if (this._triPlanarVoxelization) {\r\n            this._addRTsForRender(this._voxelMrtsXaxis, excludedMeshes, 0);\r\n            this._addRTsForRender(this._voxelMrtsYaxis, excludedMeshes, 1);\r\n            this._addRTsForRender(this._voxelMrtsZaxis, excludedMeshes, 2);\r\n        } else {\r\n            this._addRTsForRender(this._voxelMrtsZaxis, excludedMeshes, 2);\r\n        }\r\n\r\n        // Add the slab debug RT if needed.\r\n        if (this._voxelDebugEnabled) {\r\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\r\n            this._addRTsForRender([this._voxelSlabDebugRT], [], this._voxelDebugAxis, 1, true);\r\n        }\r\n\r\n        (this as any).boundVoxelGridRenderFn = this._renderVoxelGrid.bind(this);\r\n        this._scene.onAfterRenderTargetsRenderObservable.add((this as any).boundVoxelGridRenderFn);\r\n    }\r\n\r\n    private _renderVoxelGrid() {\r\n        if (this._voxelizationInProgress) {\r\n            const allRTsReady = this._renderTargets.every((rt) => rt.isReadyForRendering());\r\n            if (allRTsReady) {\r\n                (this._scene.prePassRenderer as any)._setEnabled(false);\r\n                this._renderTargets.forEach((rt) => {\r\n                    rt.render();\r\n                });\r\n                this._stopVoxelization();\r\n\r\n                if (this._triPlanarVoxelization) {\r\n                    // This hack is to prevent the procedural texture from auto-generating mips while unbinding the framebuffer.\r\n                    this._voxelGridRT._generateMipMaps = false;\r\n                    this._voxelGridRT.render();\r\n                }\r\n                this._generateMipMaps();\r\n                this._copyMipMaps();\r\n                this._voxelizationInProgress = false;\r\n                this._scene.onAfterRenderTargetsRenderObservable.removeCallback((this as any).boundVoxelGridRenderFn);\r\n                this.onReadyObservable.notifyObservers();\r\n                (this._scene.prePassRenderer as any)._setEnabled(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addRTsForRender(mrts: RenderTargetTexture[], excludedMeshes: number[], axis: number, shaderType: number = 0, continuousRender: boolean = false) {\r\n        const slabSize = 1.0 / this._computeNumberOfSlabs();\r\n        const meshes = this._scene.meshes;\r\n\r\n        // We need to update the world scale uniform for every mesh being rendered to the voxel grid.\r\n        mrts.forEach((mrt, mrtIndex) => {\r\n            mrt.renderList = [];\r\n            const nearPlane = mrtIndex * slabSize;\r\n            const farPlane = (mrtIndex + 1) * slabSize;\r\n            const stepSize = slabSize / this._maxDrawBuffers;\r\n\r\n            let voxelMaterial: ShaderMaterial;\r\n            if (shaderType === 0) {\r\n                voxelMaterial = this._createVoxelMaterial();\r\n            } else {\r\n                voxelMaterial = new ShaderMaterial(\"voxelSlabDebug\", this._scene, \"voxelSlabDebug\", {\r\n                    uniforms: [\"world\", \"viewMatrix\", \"cameraViewMatrix\", \"projection\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\r\n                    defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\r\n                });\r\n                this._scene.onBeforeRenderObservable.add(() => {\r\n                    voxelMaterial.setMatrix(\"projection\", this._scene.activeCamera!.getProjectionMatrix());\r\n                    voxelMaterial.setMatrix(\"cameraViewMatrix\", this._scene.activeCamera!.getViewMatrix());\r\n                });\r\n            }\r\n            const cameraPosition = new Vector3(0, 0, 0);\r\n            let targetPosition = new Vector3(0, 0, 1);\r\n            if (axis === 0) {\r\n                targetPosition = new Vector3(1, 0, 0);\r\n            } else if (axis === 1) {\r\n                targetPosition = new Vector3(0, 1, 0);\r\n            }\r\n            let upDirection = new Vector3(0, 1, 0);\r\n            if (axis === 1) {\r\n                upDirection = new Vector3(1, 0, 0);\r\n            }\r\n            voxelMaterial.setMatrix(\"viewMatrix\", Matrix.LookAtLH(cameraPosition, targetPosition, upDirection));\r\n            voxelMaterial.setMatrix(\"invWorldScale\", this._invWorldScaleMatrix);\r\n            voxelMaterial.setFloat(\"nearPlane\", nearPlane);\r\n            voxelMaterial.setFloat(\"farPlane\", farPlane);\r\n            voxelMaterial.setFloat(\"stepSize\", stepSize);\r\n\r\n            // Set this material on every mesh in the scene (for this RT)\r\n            meshes.forEach((mesh) => {\r\n                if (mesh instanceof Mesh && mesh.material && excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n                    mrt.renderList?.push(mesh);\r\n\r\n                    // TODO - if the mesh already has a voxel material applied, don't create a new one.\r\n                    // mesh.getMaterialForRenderPass(mrt.renderPassIds)\r\n                    mrt.setMaterialForRendering(mesh, voxelMaterial);\r\n                }\r\n            });\r\n        });\r\n\r\n        // Add the MRT's to render.\r\n        if (continuousRender) {\r\n            this._scene.customRenderTargets = this._scene.customRenderTargets.concat(mrts);\r\n        } else {\r\n            this._renderTargets = this._renderTargets.concat(mrts);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the pipeline to resize resources.\r\n     */\r\n    public resize() {\r\n        this._voxelSlabDebugRT?.resize({ width: this._scene.getEngine().getRenderWidth(), height: this._scene.getEngine().getRenderHeight() });\r\n    }\r\n\r\n    /**\r\n     * Disposes the voxel renderer and associated resources\r\n     */\r\n    public dispose() {\r\n        this._disposeVoxelTextures();\r\n        if (this._voxelSlabDebugRT) {\r\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\r\n            this._voxelSlabDebugRT.dispose();\r\n        }\r\n        if (this._voxelDebugPass) {\r\n            this._voxelDebugPass.dispose();\r\n        }\r\n        // TODO - dispose all created voxel materials.\r\n    }\r\n}\r\n"]}